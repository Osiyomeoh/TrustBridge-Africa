import { Controller, Get, Post, Query, Body, Param } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiQuery } from '@nestjs/swagger';
import { ChainlinkService } from './chainlink.service';
import { ChainlinkHederaService } from './chainlink-hedera.service';
import { ChainlinkExternalService } from './chainlink-external.service';

@ApiTags('Chainlink')
@Controller('chainlink')
export class ChainlinkController {
  constructor(
    private readonly chainlinkService: ChainlinkService,
    private readonly chainlinkHederaService: ChainlinkHederaService,
    private readonly chainlinkExternalService: ChainlinkExternalService
  ) {}

  @Get('price/:assetType')
  @ApiOperation({ summary: 'Get current asset price from Chainlink' })
  @ApiQuery({ name: 'country', required: false, description: 'Country code for localized pricing' })
  @ApiResponse({ status: 200, description: 'Current asset price' })
  async getAssetPrice(
    @Param('assetType') assetType: string,
    @Query('country') country?: string
  ) {
    const priceData = await this.chainlinkService.getAssetPrice(assetType, country || 'US');
    return {
      success: true,
      data: priceData,
      message: `${assetType} price from Chainlink`
    };
  }

  @Get('price/coffee')
  @ApiOperation({ summary: 'Get current coffee price from Chainlink' })
  @ApiQuery({ name: 'country', required: false, description: 'Country code' })
  @ApiResponse({ status: 200, description: 'Current coffee price' })
  async getCoffeePrice(@Query('country') country?: string) {
    const priceData = await this.chainlinkService.getAssetPrice('coffee', country || 'US');
    return {
      success: true,
      data: priceData,
      message: 'Coffee price from Chainlink'
    };
  }

  @Get('weather')
  @ApiOperation({ summary: 'Get weather data from Chainlink oracle' })
  @ApiQuery({ name: 'lat', required: true, description: 'Latitude' })
  @ApiQuery({ name: 'lng', required: true, description: 'Longitude' })
  @ApiResponse({ status: 200, description: 'Weather data' })
  async getWeatherData(
    @Query('lat') lat: string,
    @Query('lng') lng: string
  ) {
    if (!lat || !lng) {
      return {
        success: false,
        error: 'Latitude and longitude are required'
      };
    }

    const weatherData = await this.chainlinkService.getWeatherData(
      parseFloat(lat),
      parseFloat(lng)
    );

    return {
      success: true,
      data: weatherData,
      message: 'Weather data from Chainlink'
    };
  }

  @Get('market/:assetType')
  @ApiOperation({ summary: 'Get market data for asset type' })
  @ApiQuery({ name: 'country', required: false, description: 'Country code' })
  @ApiResponse({ status: 200, description: 'Market data' })
  async getMarketData(
    @Param('assetType') assetType: string,
    @Query('country') country?: string
  ) {
    const marketData = await this.chainlinkService.getMarketData(assetType, country || 'US');
    return {
      success: true,
      data: marketData,
      message: `Market data for ${assetType}`
    };
  }

  @Get('historical/:assetType')
  @ApiOperation({ summary: 'Get historical prices for asset' })
  @ApiQuery({ name: 'days', required: false, description: 'Number of days (default: 30)' })
  @ApiResponse({ status: 200, description: 'Historical price data' })
  async getHistoricalPrices(
    @Param('assetType') assetType: string,
    @Query('days') days?: string
  ) {
    const daysCount = days ? parseInt(days, 10) : 30;
    const historicalData = await this.chainlinkService.getHistoricalPrices(assetType, daysCount);
    return {
      success: true,
      data: historicalData,
      message: `Historical prices for ${assetType} (${daysCount} days)`
    };
  }

  @Post('vrf/random')
  @ApiOperation({ summary: 'Request random number from Chainlink VRF' })
  @ApiResponse({ status: 200, description: 'Random number generated' })
  async requestRandomNumber() {
    const vrfResult = await this.chainlinkService.requestRandomNumber();
    return {
      success: true,
      data: vrfResult,
      message: 'Random number generated by Chainlink VRF'
    };
  }

  @Post('vrf/attestor')
  @ApiOperation({ summary: 'Get random attestor using VRF' })
  @ApiResponse({ status: 200, description: 'Random attestor selected' })
  async getRandomAttestor(@Body() body: { attestorCount: number }) {
    const randomIndex = await this.chainlinkService.getRandomAttestor(body.attestorCount);
    return {
      success: true,
      data: { randomIndex, attestorCount: body.attestorCount },
      message: 'Random attestor selected using Chainlink VRF'
    };
  }

  @Post('verify/location')
  @ApiOperation({ summary: 'Verify location using external APIs' })
  @ApiResponse({ status: 200, description: 'Location verification result' })
  async verifyLocation(@Body() body: { lat: number; lng: number }) {
    const isValid = await this.chainlinkService.verifyLocation(body.lat, body.lng);
    return {
      success: true,
      data: { lat: body.lat, lng: body.lng, valid: isValid },
      message: isValid ? 'Location verified' : 'Location verification failed'
    };
  }

  @Get('feeds')
  @ApiOperation({ summary: 'Get available price feed addresses' })
  @ApiResponse({ status: 200, description: 'Price feed addresses' })
  async getPriceFeeds() {
    const feeds = this.chainlinkService.getPriceFeedAddresses();
    return {
      success: true,
      data: feeds,
      message: 'Available Chainlink price feeds'
    };
  }

  @Get('vrf/config')
  @ApiOperation({ summary: 'Get VRF configuration' })
  @ApiResponse({ status: 200, description: 'VRF configuration' })
  async getVRFConfig() {
    const config = this.chainlinkService.getVRFConfiguration();
    return {
      success: true,
      data: config,
      message: 'Chainlink VRF configuration'
    };
  }

  @Get('health')
  @ApiOperation({ summary: 'Health check for Chainlink services' })
  @ApiResponse({ status: 200, description: 'Health status' })
  async healthCheck() {
    const isHealthy = await this.chainlinkService.healthCheck();
    return {
      success: true,
      data: { healthy: isHealthy, configured: this.chainlinkService.isConfigured() },
      message: isHealthy ? 'Chainlink services are healthy' : 'Chainlink services are not responding'
    };
  }

  // New real Chainlink endpoints
  @Get('feeds/available')
  @ApiOperation({ summary: 'Get available Chainlink price feeds' })
  @ApiResponse({ status: 200, description: 'List of available price feeds' })
  async getAvailableFeeds() {
    const feeds = this.chainlinkExternalService.getAvailableFeeds();
    return {
      success: true,
      data: { feeds },
      message: `Found ${feeds.length} available Chainlink price feeds`
    };
  }

  @Get('feeds/:symbol')
  @ApiOperation({ summary: 'Get real-time price from Chainlink feed' })
  @ApiResponse({ status: 200, description: 'Real-time price data' })
  async getFeedPrice(@Param('symbol') symbol: string) {
    const priceData = await this.chainlinkExternalService.getLatestPrice(symbol);
    if (!priceData) {
      return {
        success: false,
        message: `Price feed not available for ${symbol}`
      };
    }
    return {
      success: true,
      data: priceData,
      message: `Real-time ${symbol} price from Chainlink`
    };
  }

  @Get('feeds/:symbol/info')
  @ApiOperation({ summary: 'Get Chainlink feed information' })
  @ApiResponse({ status: 200, description: 'Feed information' })
  async getFeedInfo(@Param('symbol') symbol: string) {
    const info = await this.chainlinkExternalService.getPriceFeedInfo(symbol);
    if (!info) {
      return {
        success: false,
        message: `Feed information not available for ${symbol}`
      };
    }
    return {
      success: true,
      data: info,
      message: `Feed information for ${symbol}`
    };
  }

  @Get('feeds/:symbol/historical/:roundId')
  @ApiOperation({ summary: 'Get historical price from Chainlink feed' })
  @ApiResponse({ status: 200, description: 'Historical price data' })
  async getHistoricalPrice(
    @Param('symbol') symbol: string,
    @Param('roundId') roundId: string
  ) {
    const priceData = await this.chainlinkExternalService.getHistoricalPrice(symbol, parseInt(roundId));
    if (!priceData) {
      return {
        success: false,
        message: `Historical price not available for ${symbol} round ${roundId}`
      };
    }
    return {
      success: true,
      data: priceData,
      message: `Historical ${symbol} price for round ${roundId}`
    };
  }
}
